
%group(Bonds);

%insert(obj_hpp) %{
#include <qlo/objects/obj_instruments.hpp>
#include <qlo/objects/obj_leg.hpp>
#include <qlo/objects/obj_schedule.hpp>
#include <qlo/objects/obj_indexes.hpp>

#include <ql/currency.hpp>
#include <ql/instruments/bond.hpp>
#include <ql/types.hpp>

namespace QuantLib {
    class SwapIndex;
}
%}

%insert(obj_cpp) %{
//#include <qlo/objects/obj_schedule.hpp>
//#include <qlo/objects/objmanual_termstructures.hpp>
//#include <qlo/objects/objmanual_leg.hpp>
#include <qlo/objects/obj_couponvectors.hpp>
//#include <qlo/objects/indexes/iborindex.hpp>
//#include <qlo/objects/indexes/swapindex.hpp>
#include <ql/pricingengines/bond/bondfunctions.hpp>
%}

namespace QuantLib {

    class Bond : public Instrument {
      public:

        Bond(
            const std::string& Description/*=std::string()*/,                                   //!< Bond description string. Autogenerated if null.
            const Currency& Currency/*=NullCurrency*/,                                          //!< Bond Currency.
            Natural SettlementDays/*=3*/,                                                       //!< Settlement days.
            const Calendar& Calendar/*=NullCalendar*/,                                          //!< Holiday calendar (e.g. TARGET).
            Real FaceAmount/*=100.0*/,                                                          //!< Face nominal amount.
            const Date& MaturityDate/*=QuantLib::Date()*/,                                      //!< Maturity date.
            const Date& IssueDate/*=QuantLib::Date()*/,                                         //!< Issue date: the bond can't be traded until then.
            const Leg& LegID                                                                    //!< Coupon vector Leg object ID.
        );

        //! Returns the number of settlement days of the bond.
        Natural settlementDays() const;

        //! Returns the calendar of the bond, e.g. TARGET.
        const Calendar& calendar() const;

        //! Returns the notionals of the bond.
        const std::vector<Real>& notionals() const;

        //! Returns the notional of the bond at a given date.
        virtual Real notional(
            Date SettlementDate = Date()    //!< The current bond settlement date is used if no specific date is given.
        ) const;

        //! Returns the maturity date of the bond.
        Date maturityDate() const;

        //! Returns the issue date of the bond.
        Date issueDate() const;

        //! Returns TRUE if the given Bond is tradable at the given settlement date. The current bond settlement is used if no date is given.
        bool isTradable(
            Date SettlementDate = Date()    //!< The current bond settlement date is used if no specific date is given.
        ) const;

        //! Returns the settlement date of the bond.
        Date settlementDate(
            Date EvaluationDate = Date()    //!< The current global Settings::EvaluationDate is used if no specific date is given.
        ) const;

        //! Returns the clean price for the given bond.
        Real cleanPrice() const;

        //! Returns the bond description string.
        %wrap(description);
        const std::string& description();

        //! Returns the bond currency.
        %wrap(currency);
        std::string currency();

        //! Returns the redemption amount of the bond.
        %wrap(redemptionAmount);
        Real redemptionAmount();

        //! Returns the redemption payment date of the bond.
        %wrap(redemptionDate);
        Date redemptionDate();

        //! Set the coupon pricer at the given Bond object.
        %wrap(setCouponPricer);
        void setCouponPricer(
            const boost::shared_ptr<FloatingRateCouponPricer> &FloatingRateCouponPricer         //!< FloatingRate coupon pricer object ID.
        );

        //! Set the coupon pricer at the given Bond object.
        %wrap(setCouponPricers);
        void setCouponPricers(
            const std::vector<boost::shared_ptr<FloatingRateCouponPricer> > &FloatingRateCouponPricer//!< FloatingRate coupon pricer object ID.
        );

        //! Returns the bond cash flow analysis.
        %wrap(flowAnalysis);
        std::vector<std::vector<reposit::property_t> > flowAnalysis(
            const Date& AfterDate=Date()                                                        //!< Shows only cashflows after given date
        );        
%insert(rp_class) %{
      protected:
        Bond(const boost::shared_ptr<reposit::ValueObject>& properties,
             const std::string& description,
             const QuantLib::Currency& currency,
             bool permanent);
        std::string description_;
        QuantLib::Currency currency_;
        boost::shared_ptr<QuantLib::Bond> qlBondObject_;
%}
    };

    class ZeroCouponBond : public Bond {
      public:
        ZeroCouponBond(
            const std::string& Description/*=std::string()*/,                                   //!< Bond description string. Autogenerated if null
            const Currency& Currency,                                                           //!< Bond Currency.
            Natural SettlementDays,                                                             //!< Settlement days.
            const Calendar& Calendar,                                                           //!< Holiday calendar (e.g. TARGET).
            Real FaceAmount/*=100.0*/,                                                          //!< Face nominal amount.
            const Date& Maturity,                                                               //!< Maturity date.
            BusinessDayConvention PaymentBDC=QuantLib::BusinessDayConvention(QuantLib::Following),//!< Payment business day convention.
            Real Redemption=100.0,                                                              //!< Redemption value.
            const Date& IssueDate=Date()                                                        //!< Issue date: the bond can't be traded until then.
        );
    };

    class FixedRateBond : public Bond {
      public:

        FixedRateBond(
            const std::string& Description,                                                     //!< Bond description string. Autogenerated if null
            const Currency& Currency,                                                           //!< Bond Currency.
            Natural SettlementDays,                                                             //!< settlement days.
            Real FaceAmount/*=100.0*/,                                                          //!< Face nominal amount.
            const boost::shared_ptr<Schedule>& ScheduleID,                                      //!< Schedule object ID.
            const std::vector<Rate>& Coupons,                                                   //!< Simple annual compounding coupon rates.
            const DayCounter& DayCounter,                                                       //!< Payment DayCounter ID.
            BusinessDayConvention PaymentBDC=QuantLib::BusinessDayConvention(QuantLib::Following),//!< payment business day convention.
            Real Redemption/*=100.0*/,                                                          //!< Redemption value.
            const Date& IssueDate/*=Date()*/,                                                   //!< Issue date: the bond can't be traded until then.
            const Calendar& PaymentCalendar                                                     //!< Payment holiday calendar (e.g. TARGET).
        );

        %rename(FixedRateBond2) FixedRateBond;
        FixedRateBond(
            const std::string& Description/*=std::string()*/,                                   //!< Bond description string. Autogenerated if null
            const Currency& Currency,                                                           //!< Bond Currency.
            Natural SettlementDays,                                                             //!< settlement days.
            Real FaceAmount/*=100.0*/,                                                          //!< Face nominal amount.
            const boost::shared_ptr<Schedule>& ScheduleID,                                      //!< Schedule object ID.
            const std::vector<boost::shared_ptr<InterestRate> >& Coupons,                       //!< Coupon InterestRate IDs.
            BusinessDayConvention PaymentBDC=QuantLib::BusinessDayConvention(QuantLib::Following),//!< Payment business day convention.
            Real Redemption/*=100.0*/,                                                          //!< Redemption value.
            const Date& IssueDate/*=Date()*/,                                                   //!< Issue date: the bond can't be traded until then.
            const Calendar& PaymentCalendar                                                     //!< Payment holiday calendar (e.g. TARGET).
        );
%insert(rp_class) %{
      protected:
        FixedRateBond(
            const boost::shared_ptr<reposit::ValueObject>& properties,
            const std::string& description,
            const QuantLib::Currency& currency,
            bool permanent);
%}
    };

    class FloatingRateBond : public Bond {
      public:

        FloatingRateBond(
            const std::string& Description/*=std::string()*/,                                   //!< Bond description string. Autogenerated if null
            const Currency& Currency,                                                           //!< bond Currency.
            Natural SettlementDays,                                                             //!< Settlement days.
            BusinessDayConvention PaymentBDC=QuantLib::BusinessDayConvention(QuantLib::Following),//!< Payment business day convention.
            Real FaceAmount/*=100.0*/,                                                          //!< Face nominal amount.
            const boost::shared_ptr<Schedule>& ScheduleID,                                      //!< Schedule object ID.
            Natural FixingDays/*=Null<Natural>()*/,                                             //!< Fixing days (e.g. 2).
            bool IsInArrears/*=false*/,                                                         //!< TRUE if the fixing is in arrears.
            const DayCounter& DayCounter,                                                       //!< Payment DayCounter ID.
            const std::vector<Rate>& Floors/*=std::vector<Rate>()*/,                            //!< Floor strikes.
            const std::vector<Real>& Gearings/*=1.0*/,                                          //!< Floating rate gearings.
            const boost::shared_ptr<IborIndex>& IborIndex,                                      //!< Floating rate index.
            const std::vector<Spread>& Spreads=0.0,                                             //!< Floating rate spreads.
            const std::vector<Rate>& Caps=std::vector<Rate>(),                                  //!< Cap strikes.
            Real Redemption=100.0,                                                              //!< Redemption value.
            const Date& IssueDate=Date()                                                        //!< Issue date: the bond can't be traded until then.
        );
%insert(rp_class) %{
      protected:
        FloatingRateBond(
            const boost::shared_ptr<reposit::ValueObject>& properties,
            const std::string& description,
            const QuantLib::Currency& currency,
            bool permanent);
%}
    };

    class CmsRateBond : public Bond {
      public:

        CmsRateBond(
            const std::string& Description/*=std::string()*/,                                   //!< Bond description string. Autogenerated if null
            const Currency& Currency,                                                           //!< Bond Currency.
            Natural SettlementDays,                                                             //!< Settlement days.
            BusinessDayConvention PaymentBDC=QuantLib::BusinessDayConvention(QuantLib::Following),//!< Payment business day convention.
            Real FaceAmount/*=100.0*/,                                                          //!< Face nominal amount.
            const boost::shared_ptr<Schedule>& ScheduleID,                                      //!< Schedule object ID.
            Natural FixingDays/*=Null<Natural>()*/,                                             //!< Fixing days (e.g. 2).
            bool IsInArrears/*=false*/,                                                         //!< TRUE if the fixing is in arrears.
            const DayCounter& DayCounter,                                                       //!< Payment DayCounter ID.
            const std::vector<Rate>& Floors/*=std::vector<Rate>()*/,                            //!< Floor strikes.
            const std::vector<Real>& Gearings=1.0,                                              //!< Floating rate gearings.
            const boost::shared_ptr<SwapIndex>& SwapIndex,                                      //!< Floating rate index.
            const std::vector<Spread>& Spreads,                                                 //!< Floating rate spreads.
            const std::vector<Rate>& Caps=std::vector<Rate>(),                                  //!< Cap strikes.
            Real Redemption=100.0,                                                              //!< Redemption value.
            const Date& IssueDate=Date()                                                        //!< Issue date: the bond can't be traded until then.
        );
    };

    %noctor(BondFunctions);
    struct BondFunctions {
    
        // Date inspectors
        
        //! Returns the start (i.e. first accrual) date for the given Bond object.
        %rename2(startDate, bondStartDate);
        static Date startDate(
            const Bond& ObjectId                    //!< ID of existing Bond object.
        );
        
        // CashFlow inspectors
        
        //! Returns the previous cash flow date.
        %rename2(previousCashFlowDate, bondPreviousCashFlowDate);
        static Date previousCashFlowDate(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the next cash flow date.
        %rename2(nextCashFlowDate, bondNextCashFlowDate);
        static Date nextCashFlowDate(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the previous cash flow amount.
        %rename2(previousCashFlowAmount, bondPreviousCashFlowAmount);
        static Real previousCashFlowAmount(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the next cash flow amount.
        %rename2(nextCashFlowAmount, bondNextCashFlowAmount);
        static Real nextCashFlowAmount(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        // Coupon inspectors
        
        //! Returns the previous coupon rate. Depending on (the Bond and) the given date it can be historic, deterministic or expected in a stochastic sense. When the bond settlement date is used the coupon is the last paid one.
        %rename2(previousCouponRate, bondPreviousCouponRate);
        static Rate previousCouponRate(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the next coupon rate. Depending on (the Bond and) the given date it can be historic, deterministic or expected in a stochastic sense. When the bond settlement date is used the coupon is the already-fixed not-yet-paid one.
        %rename2(nextCouponRate, bondNextCouponRate);
        static Rate nextCouponRate(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the accrual start date for the current coupon of the given bond.
        %rename2(accrualStartDate, bondAccrualStartDate);
        static Date accrualStartDate(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the accrual end date for the current coupon of the given bond.
        %rename2(accrualEndDate, bondAccrualEndDate);
        static Date accrualEndDate(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the reference period start date for the current coupon of the given bond.
        %rename2(referencePeriodStart, bondReferencePeriodStart);
        static Date referencePeriodStart(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the reference period end date for the current coupon of the given bond.
        %rename2(referencePeriodEnd, bondReferencePeriodEnd);
        static Date referencePeriodEnd(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the total accrual period for the current coupon of the given bond. The current bond settlement is used if no date is given.
        %rename2(accrualPeriod, bondAccrualPeriod);
        static Time accrualPeriod(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the total number of accrual days for the current coupon of the given bond. The current bond settlement is used if no date is given.
        %rename2(accrualDays, bondAccrualDays);
        static BigInteger accrualDays(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the accrued period for the current coupon of the given bond. The current bond settlement is used if no date is given.
        %rename2(accruedPeriod, bondAccruedPeriod);
        static Time accruedPeriod(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the accrued days for the current coupon of the given bond. The current bond settlement is used if no date is given.
        %rename2(accruedDays, bondAccruedDays);
        static BigInteger accruedDays(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the accrued amount for the given bond. The current bond settlement is used if no date is given.
        %rename2(accruedAmount, bondAccruedAmount);
        static Real accruedAmount(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        // YieldTermStructure functions

        //! Returns the bond clean price implied by the given YieldTermStructure and settlement date.
        %rename2(cleanPrice, bondCleanPriceFromYieldTermStructure);
        static Real cleanPrice(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            const YieldTermStructure& YieldCurve,   //!< Discounting YieldTermStructure object ID.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the basis point sensitivity implied by the given YieldTermStructure and settlement date.
        %rename2(bps, bondBpsFromYieldTermStructure);
        static Real bps(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            const YieldTermStructure& YieldCurve,   //!< Discounting YieldTermStructure object ID.
            Date SettlementDate = Date()            //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the ATM rate implied by the given YieldTermStructure, settlement date, and clean price.
        %rename2(atmRate, bondAtmRateFromYieldTermStructure);
        static Rate atmRate(
            const Bond& ObjectId,                   //!< ID of existing Bond object.
            const YieldTermStructure& YieldCurve,   //!< Discounting YieldTermStructure object ID.
            Date SettlementDate/*=Date()*/,         //!< The current bond settlement date is used if no specific date is given.
            Real cleanPrice                         //!< Clean price.
        );

        // Yield (a.k.a. Internal Rate of Return, i.e. IRR) functions

        //! Returns the bond clean price implied by the given yield and settlement date.
        %rename2(cleanPrice, bondCleanPriceFromYield);
        static Real cleanPrice(
            const Bond& ObjectId,                                                               //!< ID of existing Bond object.
            Rate Yield,                                                                         //!< Bond yield.
            const DayCounter& DayCounter=QuantLib::ActualActual(QuantLib::ActualActual::ISDA),  //!< Yield DayCounter ID.
            Compounding Compounding=QuantLib::Compounding(QuantLib::Compounded),                //!< Interest rate coumpounding rule (Simple:1+rt, Compounded:(1+r)^t, Continuous:e^{rt}).
            Frequency frequency=QuantLib::Frequency(QuantLib::Annual),                          //!< Frequency (e.g. Annual, Semiannual, Every4Month, Quarterly, Bimonthly, Monthly).
            Date SettlementDate=Date()                                                          //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the bond dirty price implied by the given yield and settlement date.
        %rename2(dirtyPrice, bondDirtyPriceFromYield);
        static Real dirtyPrice(
            const Bond& ObjectId,                                                               //!< ID of existing Bond object.
            Rate Yield,                                                                         //!< Bond yield.
            const DayCounter& DayCounter=QuantLib::ActualActual(QuantLib::ActualActual::ISDA),  //!< Yield DayCounter ID.
            Compounding Compounding=QuantLib::Compounding(QuantLib::Compounded),                //!< Interest rate coumpounding rule (Simple:1+rt, Compounded:(1+r)^t, Continuous:e^{rt}).
            Frequency frequency=QuantLib::Frequency(QuantLib::Annual),                          //!< Frequency (e.g. Annual, Semiannual, Every4Month, Quarterly, Bimonthly, Monthly).
            Date SettlementDate=Date()                                                          //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the basis point sensitivity implied by the given yield and settlement date.
        %rename2(bps, bondBpsFromYield);
        static Real bps(
            const Bond& ObjectId,                                                               //!< ID of existing Bond object.
            Rate Yield,                                                                         //!< Bond yield.
            const DayCounter& DayCounter=QuantLib::ActualActual(QuantLib::ActualActual::ISDA),  //!< Yield DayCounter ID.
            Compounding Compounding=QuantLib::Compounding(QuantLib::Compounded),                //!< Interest rate coumpounding rule (Simple:1+rt, Compounded:(1+r)^t, Continuous:e^{rt}).
            Frequency frequency=QuantLib::Frequency(QuantLib::Annual),                          //!< Frequency (e.g. Annual, Semiannual, Every4Month, Quarterly, Bimonthly, Monthly).
            Date SettlementDate=Date()                                                          //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the yield for the given bond corresponding to the given clean price and settlement date.
        %rename2(yield, bondYieldFromCleanPrice);
        static Rate yield(
            const Bond& ObjectId,                                                               //!< ID of existing Bond object.
            Real CleanPrice,                                                                    //!< Clean price.
            const DayCounter& DayCounter=QuantLib::ActualActual(QuantLib::ActualActual::ISDA),  //!< Yield DayCounter ID.
            Compounding Compounding=QuantLib::Compounding(QuantLib::Compounded),                //!< Interest rate coumpounding rule (Simple:1+rt, Compounded:(1+r)^t, Continuous:e^{rt}).
            Frequency frequency=QuantLib::Frequency(QuantLib::Annual),                          //!< Frequency (e.g. Annual, Semiannual, Every4Month, Quarterly, Bimonthly, Monthly).
            Date SettlementDate = Date(),                                                       //!< The current bond settlement date is used if no specific date is given.
            Real Accuracy = 1.0e-10,                                                            //!< Tolerance.
            Size MaxIterations = 100,                                                           //!< Max number of iterations.
            Rate Guess = 0.05                                                                   //!< Guess.
        );

        //! Returns the duration implied by the given yield and settlement date.
        %rename2(duration, bondDurationFromYield);
        static Time duration(
            const Bond& ObjectId,                                                               //!< ID of existing Bond object.
            Rate Yield,                                                                         //!< Bond yield.
            const DayCounter& DayCounter=QuantLib::ActualActual(QuantLib::ActualActual::ISDA),  //!< Yield DayCounter ID.
            Compounding Compounding=QuantLib::Compounding(QuantLib::Compounded),                //!< Interest rate coumpounding rule (Simple:1+rt, Compounded:(1+r)^t, Continuous:e^{rt}).
            Frequency frequency=QuantLib::Frequency(QuantLib::Annual),                          //!< Frequency (e.g. Annual, Semiannual, Every4Month, Quarterly, Bimonthly, Monthly).
            Duration::Type DurationType = QuantLib::Duration::Type(QuantLib::Duration::Modified),//!< Duration type (Simple, Macaulay, or Modified).
            Date SettlementDate = Date()                                                        //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the convexity implied by the given yield and settlement date.
        %rename2(convexity, bondConvexityFromYield);
        static Real convexity(
            const Bond& ObjectId,                                                               //!< ID of existing Bond object.
            Rate Yield,                                                                         //!< Bond yield.
            const DayCounter& DayCounter=QuantLib::ActualActual(QuantLib::ActualActual::ISDA),  //!< Yield DayCounter ID.
            Compounding Compounding=QuantLib::Compounding(QuantLib::Compounded),                //!< Interest rate coumpounding rule (Simple:1+rt, Compounded:(1+r)^t, Continuous:e^{rt}).
            Frequency frequency=QuantLib::Frequency(QuantLib::Annual),                          //!< Frequency (e.g. Annual, Semiannual, Every4Month, Quarterly, Bimonthly, Monthly).
            Date SettlementDate = Date()                                                        //!< The current bond settlement date is used if no specific date is given.
        );

        // Z-spread functions

        //! Returns the bond clean price implied by the given Z-Spread, discount curve, and settlement date.
        %rename2(cleanPrice, bondCleanPriceFromZSpread);
        static Real cleanPrice(
            const Bond& ObjectId,                                                               //!< ID of existing Bond object.
            const boost::shared_ptr<YieldTermStructure>& YieldCurve,                            //!< Discounting YieldTermStructure object ID.
            Spread ZSpread,                                                                     //!< the Z-spread.
            const DayCounter& DayCounter=QuantLib::ActualActual(QuantLib::ActualActual::ISDA),  //!< Yield DayCounter ID.
            Compounding Compounding=QuantLib::Compounding(QuantLib::Compounded),                //!< Interest rate coumpounding rule (Simple:1+rt, Compounded:(1+r)^t, Continuous:e^{rt}).
            Frequency frequency=QuantLib::Frequency(QuantLib::Annual),                          //!< Frequency (e.g. Annual, Semiannual, Every4Month, Quarterly, Bimonthly, Monthly).
            Date SettlementDate = Date()                                                        //!< The current bond settlement date is used if no specific date is given.
        );

        //! Returns the z-spread for the given bond corresponding to the given clean price and settlement date.
        %rename2(zSpread, bondZSpreadFromCleanPrice);
        static Spread zSpread(
            const Bond& ObjectId,                                                               //!< ID of existing Bond object.
            Real CleanPrice,                                                                    //!< Clean price.
            const boost::shared_ptr<YieldTermStructure>& YieldCurve,                            //!< Discounting YieldTermStructure object ID.
            const DayCounter& DayCounter=QuantLib::ActualActual(QuantLib::ActualActual::ISDA),  //!< Yield DayCounter ID.
            Compounding Compounding=QuantLib::Compounding(QuantLib::Compounded),                //!< Interest rate coumpounding rule (Simple:1+rt, Compounded:(1+r)^t, Continuous:e^{rt}).
            Frequency frequency=QuantLib::Frequency(QuantLib::Annual),                          //!< Frequency (e.g. Annual, Semiannual, Every4Month, Quarterly, Bimonthly, Monthly).
            Date SettlementDate = Date(),                                                       //!< The current bond settlement date is used if no specific date is given.
            Real Accuracy = 1.0e-10,                                                            //!< Tolerance.
            Size MaxIterations = 100,                                                           //!< Max number of iterations.
            Rate Guess = 0.05                                                                   //!< Guess.
        );
    };
}    

namespace QuantLibAddin {

    //! filters the Bond object IDs of the still alive Bonds.
    std::vector<std::string> bondAlive(
        const std::vector<boost::shared_ptr<Bond> >& Bonds,                                     //!< Vector of Bond IDs.
        QuantLib::Date& RefDate=QuantLib::Date()                                                //!< Reference date at which evaluate alive bonds. The current evaluation date is used if no specific date is given.
    );

    //! returns the first maturity-matching Bond object ID.
    std::string bondMaturityLookup(
        const std::vector<boost::shared_ptr<Bond> >& Bonds,                                     //!< Vector of Bond IDs.
        const QuantLib::Date& Maturity                                                          //!< Maturity date to look up Bonds for.
    );

    //! sorts the Bond object IDs by maturity.
    std::vector<std::string> bondMaturitySort(
        const std::vector<boost::shared_ptr<Bond> >& Bonds                                      //!< Vector of Bond IDs.
    );
}

